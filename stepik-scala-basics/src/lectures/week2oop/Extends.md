### Наследование
Благодаря наследованию - класс может получить доступ к полям и методам другого класса (с условием, что те не отмечены, как private). Наследование производится посредством ключевого слова extends.

 

Давайте объявим класс Person, в котором создадим метод greet. И затем создадим новый класс Student, расширяющий ранее созданный класс Person.

  class Person {
    def greet: String = "Hello"
  }

  class Student extends Person

  val student = new Student
  println(student.greet)
Как видите, если создать экземпляр класса Student, будет возможно обратиться к методу greet класса Person. А все благодаря наследованию.

![image](https://user-images.githubusercontent.com/47192124/169690905-b027514b-f989-4019-b97b-4d2e6cddc55d.png)


### protected vs private
При наследовании у нас появляется доступ ко всем полям и методам родительского класса, которые не являются private.

Ключевое слово private, написанное перед методом и/или переменной, делает этот метод и/или переменную доступным только для того класса, в котором он и/или она были описаны:

![image](https://user-images.githubusercontent.com/47192124/169690910-68514e40-2ce5-486a-af99-dd527b1b0030.png)

protected работает немного по другому, делая отмеченные поля и методы доступными для класса и его подкласса, но недоступными вне их тел

![image](https://user-images.githubusercontent.com/47192124/169690912-a03ddfc9-fa8f-4d23-852e-7415449f8c44.png)

extend для класса с параметрами
Теперь поработаем с конструкторами. Посмотрите на код и на ошибку:

![image](https://user-images.githubusercontent.com/47192124/169690922-740074d1-bc15-430e-8c03-028b34d6db05.png)



Причиной ошибки является то, что при создании экземпляра класса Student - сначала потребуется совершить вызов конструктора из родительского класса.

Чтобы все заработало - необходимо доуказать пропущенные параметры:


![image](https://user-images.githubusercontent.com/47192124/169690926-2a8a8ea7-8705-47d1-b757-4c1d28624edf.png)


Либо можно выкрутиться через вспомогательный конструктор def this (вспоминаете начало модуля?). И теперь компилятор будет находить конструктор класса Person, который не требует никаких параметров, и все будет работать:

![image](https://user-images.githubusercontent.com/47192124/169690932-b567951e-28ff-4922-bd9a-cff52efaa990.png)

### Переопределение (override)
Применяется, когда для подкласса хотим применить метод из родительского класса, но с имплементацией, отличной от начальной. Либо когда необходимо изменить значение переменной родительского класса.

Для переопределения метода или переменной используем ключевое слово override. Причем поля, в отличие от методов, могут быть переопределены в конструкторе класса:


![image](https://user-images.githubusercontent.com/47192124/169690939-022e9055-1d8f-4973-a10e-22fc8ff233b1.png)

 
Super
Полезно, когда хотим воспользоваться имплементацией метода или значением переменной из родительского класса. И в то же время прикрутить к этому что-то свое. Для этого всего-лишь надо применить ключевое слово super. Смотрите на пример, сразу должно стать понятно:

![image](https://user-images.githubusercontent.com/47192124/169690942-d6b72eb8-ed68-49d1-9504-b05898070cb1.png)

### Полиморфизм (polymorphism)
Полиморфизм подразумевает замену типов. Смотрим пример:

![image](https://user-images.githubusercontent.com/47192124/169690954-70419fa7-0b40-4227-8ed0-013d977a64d1.png)


Хотя и объявили переменную aPerson с типом Person, но использовать она будет средства Student, т.к. является экземпляром класса Student - полиморфизм в действии.

### Защита от переопределения
Есть несколько способов:

1. использование ключевого слова final перед членами класса, для которых нужно запретить override

![image](https://user-images.githubusercontent.com/47192124/169690966-ce8f4fa8-4f02-46b3-9040-6bf254c55cfb.png)

2. использование ключевого слова final для целого класса (что вообще запретит extends этого класса )

![image](https://user-images.githubusercontent.com/47192124/169690969-6f571444-9733-4550-9dea-b5997d3d81cd.png)

3. использование ключевого слова sealed для класса (это более мягкая версия final, поэтому допускается extends в текущем файле, но воспрещается вне этого файла)

![image](https://user-images.githubusercontent.com/47192124/169690971-487b1799-d92a-4ffd-bda7-aacbef0d0fa2.png)

sealed довольно полезная штука, когда надо гарантировать существование подклассов, определяемых только в текущем файле. Если попытаться привести практический пример, представьте, вы описываете дни недели. Использование sealed гарантирует, что существовать будут только те дни, что конкретизированы в текущем файле, и нигде вдруг случайно не всплывет доселе невиданный восьмой день недели.

То, что вы будете знать, какие дни вам доступны - создает благоприятные условия для применения шаблонов, если они потребуются.

Примечание: да, знаем, ни шаблоны, о которых вскользь упомянули, ни абстрактные классы, ни case классы мы еще не проходили, но дали именно этот пример. Мы решили, что лучше будет показать, как это должно быть на самом деле, и дать мотивацию быстрее узнать новое, чем упростить пример и повысить риски того, что вы запомните упрощенную версию и будете ее внедрять в своей практике. Суть sealed вы должны уловить, а к этому примеру можно будет вернуться через некоторое время, когда недостающие знания будут получены.
```
  sealed abstract class DayOfTheWeek(val name: String, val isWeekend: Boolean)

  case object Monday extends DayOfTheWeek("Monday", false)
  case object Tuesday extends DayOfTheWeek("Tuesday",  false)
  case object Wednesday extends DayOfTheWeek("Wednesday", false)
  case object Thursday extends DayOfTheWeek("Thursday", false)
  case object Friday extends DayOfTheWeek("Friday", false)
  case object Saturday extends DayOfTheWeek("Saturday", true)
  case object Sunday extends DayOfTheWeek("Sunday", true)
```


### Абстрактные классы (abstract classes)
Бывают ситуации, когда небходимо в классе задать только поле или метод, а имплементацию прописывать в подклассах, подстраивая ее под каждый конкретный случай.

 

В абстрактном классе абстрактные поля мы оставляем пустыми, а абстрактные методы без тела. Это значит, что мы не можем создать экземпляр абстрактного класса, пока абстрактные методы и поля не прописаны должным образом.

<img src="https://user-images.githubusercontent.com/47192124/169690999-6f34be36-1bc0-4ce8-9c46-0350e46aee04.png" width="600" height="500" />

### Анонимные классы (Anonymous classes)
Мы отметили, что мы не можем создать экземпляр абстрактного класса, пока абстрактные методы и поля не прописаны должным образом. Но тогда что же получается, если написать вот так, избежав создания подкласса:

  val someSource = new BaseDataSource("someDS") {
    override val user: String = "someSourceUser"

    override def connect: String = "someSource connection"
  }

  
А получается анонимный класс.

![image](https://user-images.githubusercontent.com/47192124/169691032-08dc6f91-0e09-45fe-a44d-b28da1674d5e.png)

Трейты (traits)
Очень похожи на абстрактные классы. Как и абстрактные классы,  трейты могут включать в себя неабстрактных членов. Но все же трейты - это не абстрактные классы. И причин этому несколько:

трейты не могут задаваться с параметрами
можно указать несколько трейтов для одного класса
трейты описывают конкретное поведение для конкретной ситуации
![image](https://user-images.githubusercontent.com/47192124/169691036-96842d1b-ae7a-4856-8e0c-878d9d347b8e.png)









