## Класс
Если все упростить, то класс можно рассматривать как чертеж.

Смотрите: вы сделали чертеж автомобиля. И теперь хотите получить его материальное воплощение. Для этого вы обращаетесь на завод, где по вашим чертежам и с заданными параметрами(цвет, количество дверей и тд) строится реальный объект - экземпляр вашего класса. Причем функционал созданного вами экземпляра определяется описанными в классе методами.

 

Если посмотреть на код, то класс объявляется с помощью ключевого слова class, за которым следует имя класса:
```
  class Student
```
Созданиие экземпляра класса происходит при содействии ключевого слова new

```
val student = new Student
```
Тут все довольно просто. Так что давайте немного усложним наш класс Student - все-таки обычно у студента есть имя, да и свой id бы неплохо было иметь.

### Конструктор класса

Если посмотреть на то, как мы задаем параметры в классе, то увидим, насколько это похоже на синтаксис функций.

Синтаксис-то похож, но смысл разный. В случае класса вот эту часть ```Student(id: Int, name: String)``` мы называем конструктором. Конструктор говорит, что каждый экземпляр класса должен обладать именем и id.

 

У студента появилось имя, которое бы неплохо было использовать в программе. Интуитивно - хочется написать ```student.name```, вот только это не сработает:

![image](https://user-images.githubusercontent.com/47192124/169690181-bcd4ca3c-4128-4c91-b873-3818565f3dd2.png)

Вся соль тут в том, что  параметр класса еще не член класса, доступ к которому можно получить через точку. Чтобы этот доступ сделать возможным - необходимо добавить ключевое слово val или var, прописав его перед параметром. Тогда мы получим поле класса, к которому можно при необходимости обратиться.

![image](https://user-images.githubusercontent.com/47192124/169690185-c7fd4d16-3d0e-4e71-93db-6bab76bb1b64.png)

### Тело класса
Тело класса описываем в фигурных скобках (как и блоки кода). Ко всему, что мы определяем в теле класса, можно получить доступ через точку.

![image](https://user-images.githubusercontent.com/47192124/169690221-29581a87-f691-464b-9931-015013ba62b2.png)


А теперь пропишем print в теле класса. А другим выведем значение переменной student.name. Как думаете, что будет?

![image](https://user-images.githubusercontent.com/47192124/169690229-c948f39e-0c2c-4351-ad07-74757acecfe4.png)

Как видите, значение name печатается последним. Это связано с тем, что при создании экземпляра класса автоматически исполняются все конструкции, описанные внутри класса.

### Методы класса
Для вызова метода также применяется точечная нотация.

Ключевой момент, который вам стоит запомнить - это то, как использование ключевого слова this влияет на результат программы. Рассмотрим действие this на примере getId - внимание на результат:

![image](https://user-images.githubusercontent.com/47192124/169690252-365b9a21-a1c8-40d2-b2a5-cb4d1402104c.png)
this позволяет компилятору различать параметры класса и параметры метода класса.

### Перегрузка метода(Overloading)
Позволяет иметь функции с одинаковым названием.

Единственное условие - чтобы набор аргументов  и(или) их тип был разный, чтобы компилятор мог понять, вызов какой именнно функции вам требуется.
![image](https://user-images.githubusercontent.com/47192124/169690264-122d8517-5e9c-49bc-a3f0-f7e6714aa354.png)

### Перегруженные конструкторы
Класс может иметь несколько конструкторов. Это достигается за счет использования def this. Допустим, нам нужен конструктор, который бы по умолчанию использовал 0 в качестве значения id:

![image](https://user-images.githubusercontent.com/47192124/169690280-e4349291-3d8e-4e6b-b25e-1bc0cc88f854.png)





