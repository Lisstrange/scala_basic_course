## Классы образцы (Case classes)
Мы, может, медленно, зато верно подбираемся к функциональному программированию. Чтобы завершить эту неделю и закрыть тему классов, но в то же время немного приоткрыть, что же вас ждет на следующей неделе - рассмотрим классы образцы.

 

Одной из основных идей функционального программирования является то, что мы стараемся разделить структуры данных и операции над ними. Т.е. все функции обычно сбрасываются в трейты и объекты, но никак не в обычные классы (их вообще желательно избегать, если того позволяет бизнес-логика вашего приложения, прибегая к case классам).

Однако существует набор методов, которые всегда придутся кстати для любого класса. Именно доступ к таким методам и дают классы образцы, избавляя вас от необходимости имплементировать эти методы вручную.

 

Объявить класс образец очень легко. Надо всего лишь дописать ключевое слово case.
```
  case class Person(name: String, occupation: String)
```

Далее опишем, какие преимущества нам дает использование case классов (единственное, что не рассмотрим, это преимущество, связанное с шаблонами - но не волнуйтесь, в следующем модуле все будет )

## Параметры класса по умолчанию являются val полями.
Это значит, что вы автоматически получаете к ним доступ без дополнительных манипуляциий:

![image](https://user-images.githubusercontent.com/47192124/169691834-2d2d261e-744d-46fc-a0a6-2b9850802a42.png)

## Информация сразу выводится в понятном виде
Метод toString (который имеет свой синтаксический сахар, поэтому можно обойтись вообще без явного прописывания имени этого метода в коде) избавляет вас от абракадабры, выводимой в обычном классе.

![image](https://user-images.githubusercontent.com/47192124/169691845-5787b5dd-8591-479a-b1bc-ef243e4b57ce.png)

## Доступен метод equals
Обычно при обсуждении метода equals( == ) принято говорить о reference level equality и content level equality. Одним из свойств case class’ов является обязательное наличие списка параметров (пусть даже пустого), что объясняет существование прописанного специально для них метода equals, представляющего content level equality и позволяющего производить сравнение по структуре, а не по ссылкам.

Поэтому, если создать двойника Боба(bobsDouble), а затем сравнить двойника с оригиналом, то в случае case класса - получим true, хотя обычный класс выдаст false.

![image](https://user-images.githubusercontent.com/47192124/169691855-9c4b186a-f011-4be7-839c-cedada8b8c52.png)

## Доступен метод copy
Метод позволяет как полностью скопировать экземпляр класса, так и скопировать с измененными аргументами конструктора. 
```
  case class Person(name: String, occupation: String)

  val bob = Person("Bob", "Developer")

  val anotherBob = bob.copy()
  println(bob) // Person(Bob,Developer)
  println(anotherBob) // Person(Bob,Developer)

  val bobsTwin = bob.copy(name = "John")
  println(bobsTwin) // Person(John,Developer)
```

## Любой case класс имеет объект-компаньон
В таком объекте-компаньоне всегда присутствует метод apply. Которым можно воспользоваться и сделать так:
```
  case class Person(name: String, occupation: String)
  val alice = Person("Alice", "Engineer") // метод apply в действии
```
Т.е. мы создали  экземпляр класса без использования ключевого слова new.




