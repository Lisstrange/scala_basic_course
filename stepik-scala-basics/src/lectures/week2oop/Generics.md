#Обобщения (Generics)
Допустим, вы написали программу, рассчитывающую сумму имеющихся у вас накоплений. Программа прекрасно работает с числами типа Int. Но в один момент вы захотели увеличить точность расчетов и поюзать тип Double. И что же тогда?

Тогда можно, конечно, скопировать - вставить код, а затем везде в нем, где того требует логика, заменить Int на Double. А вдруг станет нужен Float. И что - опять копировать? Чувствуте, насколько идея не айс. И вот тут полезно будет вспомнить про обобщения.

Обобщения - это такая штука, которая позволяет нам использовать один и тот же код, но для разных типов данных.

 

Поработаем немного со списками. Допустим, вы знаете, что придется хранить данные в виде списка. Вот только тип этих данных вам пока неизвестен. А это - отличный повод воспользоваться обобщениями. Тогда класс для работы со списками будем создавать вот так:
```
 class MyList[A] 
```
A в квадратных скобках означает тип данных, которые могут храниться в вашем списке. Этот тип будет конкретизирован непосредственно в момент создания списка:
```
  val listOfStrings = new MyList[String]
  val listOfDoubles = new MyList[Double]
  val listOfInts = new MyList[Int]
```

Примечание:

по соглашению в скобках [ ] обычно указываются заглавные буквы типа A, B, С, ... 
обобщения применяются к классам(class), трейтам(trait),  но никак не к объектам (object)

### Обобщенные методы
Допустим, у нас есть метод, рандомно выбирающий число из целочисленного списка:
```
  def randomInt(items: List[Int]): Int = {
    val randomIndex = util.Random.nextInt(items.length)
    items(randomIndex)
  }

  println(randomInt(List(1, 2, 3, 4, 5)))
``` 

Если мы хотим на вход подавать списки любого типа. Тогда имеет смысл создать обобщенный метод, переписав функцию вот так:
```
  def randomItem[A](items: List[A]): A = {
    val randomIndex = util.Random.nextInt(items.length)
    items(randomIndex)
  }

  println(randomItem(List("a", "bc", "def")))
  println(randomItem(List(1.5, 2.75, 3.8)))
```


### Вариативность (Variance problem)
Посмотрите на вот такую иерархию классов:
```
  class Fruit

  class Apple extends Fruit

  class Banana extends Fruit
```
Как думаете: если ```Apple``` расширяет класс ```Fruit```, то можно ли подобное утверждать применительно к спискам ```List[Apple]``` и ```List[Fruit]```? Ответов на данный вопрос целых три. И связаны они с ковариантностью, инвариантностью и контравариантностью.

Краткая шпаргалка по ковариантности, инвариантности и контравариантности представлена ниже, а подробный разбор каждого случая будет дан в дальнейших шагах.

## Инвариантность(Invariance)
Инвариантность диктует, что List[Apple] и List[Fruit] - это совершенно разные вещи, не связанные никакими родственными связями.

 

Тип, указанный в скобках без каких-либо дополнительных знаков, свидетельствует об инвариантности:
```
  class InvariantList[A]
```
Поэтому вот так сделать не получится:

![image](https://user-images.githubusercontent.com/47192124/169691568-d8c976d3-1ba4-47f2-ab5b-5e7c7a816a40.png)


Только так(т.е. тип, указанный слева, должен совпадать с типом в правой части):
```
  class InvariantList[A]
  val invariantFruitList: InvariantList[Fruit] = new InvariantList[Fruit]
```

## Контравариантность (Contravariance)
Контравариантность предполагает знак минус рядом с типом:
```
  class ContravariantList[-A]
```
И тогда создаем вот такую переменную:

  ```val contravariantList: ContravariantList[Apple] = new ContravariantList[Fruit]```
 

Пример с фруктами неплохой, но не очень интуитивный. Давайте перепишем вот так:
```
  class Person[-A]

  val person: Person[ScalaDeveloper] = new Person[Developer]
```
Представьте ситуацию: вы искали Scala-разработчика к себе в команду, а наняли отличного разработчика, знания которого не ограничены одним лишь языком Scala. Вы ведь от этого только выиграете: у работника больше знаний, больше умений, а значит - больше задач, которые он сможет успешно выполнить.

### Ограниченные типы (Bounded types)
Перед тем, как рассмотреть ковариантность, давайте поговорим об ограничениях. Мы ведь можем ограничить типы, подходящие для нашего обобщенного класса, сказав использовать либо только подтипы, либо только супер типы.

 

Верхнее ограничение типа T <: A
```
  class Fruit
  class Apple extends Fruit
  class Banana extends Fruit
 
  class Food[T <: Fruit](fruit: T)
  val food = new Food(new Banana)
```
Таким образом - мы говорим, что классу Food подходят только параметры типа T, причем этот тип должен быть подтипом Fruit. Так как Banana extends Fruit, то Banana нам отлично подойдет.

 

А вот тут номер не пройдет, т.к. никаких связей между Pizza и Fruit у нас не задано.
```
  class Food[T <: Fruit](fruit: T)
  val food = new Food(new Banana)

  class Pizza
  val moreFood = new Food(new Pizza)
```
И хотя предварительно никакого сообщения об ошибке вы не увидите, запустить код вы не сможете, лишь словите inferred type arguments do not conform to value <local Food>'s type parameter bounds...

 

Нижнее ограничение типа T >: A
```
  class Fruit
  class Apple extends Fruit
  class Banana extends Fruit
 
  class Food[T >: Fruit](fruit: T)
```
Теперь в качестве типа T нам подходят только супертипы типа Fruit.

## Ковариантность (Covariance)
Ковариантность подразумевает, что раз Apple наследуется от ```Fruit```, то и ```List[Apple]``` можно  рассматривать как потомка ```List[Fruit]```.

 

Для обозначения ковариантного списка - не забудьте добавить плюс перед типом:
```
  class CovariantList[+A]
```
Тогда можно сказать, что раз справедлив вот такой код:
```
  class Fruit
  class Apple extends Fruit
  class Banana extends Fruit 
 
  val fruit: Fruit = new Apple
```
То прекрасно сработает и вот такой:
```
  val fruitList: CovariantList[Fruit] = new CovariantList[Apple]
 ```

Но тогда воппрос: сможем ли мы добавить Banana в наш список, сделав вот так:

  fruitList.add(new Banana)
Ведь хотя у нас и список Fruit но на самом деле он создавался для одних яблок(new CovariantList[Apple]) - так не порушит ли банан всю систему? На самом деле - нет. Просто из списка яблок - список превратится в то, чем и должен был быть изначально, в список фруктов.

 

Давайте напишем имплементацию метода add, чтобы точно видеть - какие типы, как и где указывать.
```
  class List[+A] {
    def add[B >: A](element: B): List[B] = ???
  }
```
Этим кодом мы говорим, что если в список типа A будет добавлен элемент типа B, то список типа A превратится в список типа B, причем B является супер типом для A.



