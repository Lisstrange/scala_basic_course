## Функции высшего порядка (High Order Functions)
Под функциями высшего порядка понимают такие функции, которые на вход получают другую функцию или же, как результат, возвращают функцию.

 

В качестве примера напишем функцию nTimes, которая получает на вход три параметра: f, x, n. f - это та функция, которая будет применена к параметру x указанное количество раз (в нашем случае это n раз). 

 

Функцию nTimes можно написать несколькими способами. Способ 1, в котором мы передаем все три аргумента сразу - в одних скобках:
```
  @tailrec
  def nTimes(f: Int => Int, x: Int,  n: Int): Int = {
    if (n <= 0) x
    else nTimes(f, f(x), n - 1)
  }
 ```

В качестве функции, которую будем передавать в качестве аргумента, возьмем функцию, увеличивающую число на единицу:
```
  val increment = (x: Int) => x + 1
```
Тогда запуск функции nTimes будет выглядеть следующим образом:
```
  println(nTimes(increment, 0, 3)) // выведет 3
```

## Каррированные функции (Currying Functions)
Перед тем, как мы рассмотрим второй способ написания функции nTimes, давайте разберемся, что же такое каррирование.

Итак, под каррированной функцией подразумевают функцию, которая на вход принимает несколько аргументов (причем - можно сказать, что аргументы разбиты на группы). А в теле этой функции происходит серия вызовов функций, каждая из которых принимает единственный аргумент

Опять же, обращаясь к алгебрe, расписать весь процесс можно примерно так:
```
f1 = f(x)
f2 = f1(y)
result = f2(z)
```
Иначе говоря:
```
result = f(x)(y)(z)
```

Посмотрите на пример функции сложения. Можно написать так:
```
  def add(x: Int, y: Int) = x + y

  println(add(1, 2)) // 3
```
А можно так (внимание на аргументы):
```
  def add(x: Int) = (y: Int) => x + y
```
  println(add(1)(2)) // 3
Или еще вот так:
```
  def add(x: Int)(y: Int) = x + y

  println(add(1)(2))
``

Примечание: исходя из нашего опыта, мы бы не сказали, что в работе каррирование вам так уж часто пригодится, но вот знать, что и такое есть в Scala - точно не помешает.

## А теперь, собственно, второй способ написания функции из первого шага, но уже через каррирование.

 

Способ 2. curryingdNTimes: (f, n) (x)

Выглядеть это теперь будет так:

def имяФункции(аргумент1, агрумент2) = (аргумент3) => операция
Или, может, для кого-то более понятной будет вот такая запись:
``
curryingNTimes(f,n) = x => f( f(f...f(x) ) )
```
 

И сам код:
```
  def curryingNTimes(f: Int => Int, n: Int): Int => Int = {
    if (n <= 0) (x: Int) => x // лямбда-функция, что просто берет и возвращает значение
    else (x: Int) => curryingNTimes(f, n-1)(f(x))
  }
```
Сам вызов теперь будет иметь следующий формат:
```
  println(curryingNTimes(increment, 3)(0))
```
Возможно, такой стиль вам может показаться запутанным и непонятным, но не волнуйтесь, немного практики - и вы без труда будете писать подобный код.


